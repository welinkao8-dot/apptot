import { useState, useEffect, useRef } from 'react'
import { useAuth } from '../context/AuthContext'
import { Menu, User, DollarSign, Navigation, Clock, Power, CheckCircle, ChevronRight, MapPin, Home, History, LogOut, Play, Square, CreditCard, Phone, MessageSquare, Maximize2, Minimize2, ArrowUp, ArrowLeft, ArrowRight, CornerUpLeft, CornerUpRight, RotateCcw } from 'lucide-react'
import { toast } from 'react-hot-toast'
import axios from 'axios'
import { useNavigate, Link } from 'react-router-dom'
import { io } from 'socket.io-client'
import HereMap from '../components/HereMap'
import { hereRoutingService } from '../services/hereRoutingService'
import './Dashboard.css'

// Helper para √≠cones de manobra
const getManeuverIcon = (action) => {
    switch (action) {
        case 'turn-left': return <CornerUpLeft size={32} color="white" />;
        case 'turn-right': return <CornerUpRight size={32} color="white" />;
        case 'uturn-left':
        case 'uturn-right': return <RotateCcw size={32} color="white" />;
        case 'sharp-left': return <ArrowLeft size={32} color="white" />;
        case 'sharp-right': return <ArrowRight size={32} color="white" />;
        default: return <ArrowUp size={32} color="white" />;
    }
}

const translateInstruction = (instruction) => {
    if (!instruction) return ''
    // Basic translation map for HERE API instructions
    return instruction
        .replace(/Go for /gi, '') // Remove 'Go for' text as requested
        .replace(/Head/gi, 'Siga')
        .replace(/Turn left/gi, 'Vire √† esquerda')
        .replace(/Turn right/gi, 'Vire √† direita')
        .replace(/Keep left/gi, 'Mantenha-se √† esquerda')
        .replace(/Keep right/gi, 'Mantenha-se √† direita')
        .replace(/Take the exit/gi, 'Pegue a sa√≠da')
        .replace(/Arrive at/gi, 'Chegando em')
        .replace(/onto/gi, 'na')
        .replace(/towards/gi, 'em dire√ß√£o a')
        .replace(/street/gi, 'Rua')
        .replace(/avenue/gi, 'Avenida')
}



const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3004'
const SOCKET_URL = import.meta.env.VITE_SOCKET_URL || API_URL.replace('/auth', '') // Ensure socket points to base

export default function Dashboard() {
    const { user, signOut } = useAuth()
    const navigate = useNavigate()
    const [isOnline, setIsOnline] = useState(false)
    const [stats, setStats] = useState({ rides: 0, earnings: 0 })
    const [requests, setRequests] = useState([])

    // STATE RESILIENCE: Hydrate from localStorage to survive refresh
    const [activeRide, setActiveRide] = useState(() => {
        const saved = localStorage.getItem('tot_active_ride')
        return saved ? JSON.parse(saved).ride : null
    })
    const [rideStatus, setRideStatus] = useState(() => {
        const saved = localStorage.getItem('tot_active_ride')
        return saved ? JSON.parse(saved).status : 'idle'
    })

    const [fare, setFare] = useState(0)
    const [isModalMinimized, setIsModalMinimized] = useState(false)
    const [navigationInstructions, setNavigationInstructions] = useState([]) // Array de manobras
    const [currentManeuver, setCurrentManeuver] = useState(null) // Pr√≥xima manobra
    const [rideStats, setRideStats] = useState({ distance: '...', time: '...' }) // New Trip Stats
    const [forceRouteUpdate, setForceRouteUpdate] = useState(0) // Moved to top to avoid TDZ error

    const socketRef = useRef(null)
    const fareInterval = useRef(null)
    const currentRouteRef = useRef(null) // Defined here
    const isRecalculating = useRef(false) // Defined here
    const lastProgressIndex = useRef(0) // Track route progress
    const completedPolylineRef = useRef(null) // Completed route segment
    const remainingPolylineRef = useRef(null) // Remaining route segment
    const transitionPolylineRef = useRef(null) // Transition segment at current position



    // Armazena √∫ltima posi√ß√£o conhecida para enviar junto com o tax√≠metro
    const latestCoords = useRef({ lat: -8.84, lng: 13.29 })

    const fetchStats = async () => {
        try {
            if (!user) return
            const res = await axios.get(`${API_URL}/trips/stats/${user.id}`)
            if (res.data) {
                setStats(res.data)
            }
        } catch (error) {
            console.error('Error fetching stats:', error)
        }
    }

    const fetchPendingTrips = async (currentStatus = isOnline) => {
        if (!currentStatus) return
        try {
            console.log('üì° Buscando corridas pendentes via HTTP Fallback...')
            const res = await axios.get(`${API_URL}/trips/pending`)
            if (res.data) {
                setRequests(res.data)
                console.log(`‚úÖ ${res.data.length} corridas carregadas via HTTP.`)
            }
        } catch (error) {
            console.error('‚ùå Erro no fallback HTTP:', error)
        }
    }

    // GERENCIAMENTO DE GPS EM TEMPO REAL
    useEffect(() => {
        let watchId = null

        if (isOnline && socketRef.current) {
            if ('geolocation' in navigator) {
                console.log('üì° Iniciando GPS Tracker...')
                watchId = navigator.geolocation.watchPosition(
                    (position) => {
                        const { latitude, longitude } = position.coords
                        latestCoords.current = { lat: latitude, lng: longitude }

                        // Atualizar marcador no mapa local se visualmente necess√°rio
                        updateDriverMarker(latitude, longitude)

                        // NAVEGA√á√ÉO INTELIGENTE: Verificar desvio e atualizar manobras
                        if (activeRide && (rideStatus === 'accepted' || rideStatus === 'ongoing')) {
                            checkRouteDeviation(latitude, longitude)
                            updateNavigationState(latitude, longitude)

                            // PREMIUM FEATURE: Update route progress
                            if (currentRouteRef.current) {
                                const progress = calculateRouteProgress(
                                    currentRouteRef.current,
                                    { lat: latitude, lng: longitude }
                                )

                                if (progress && progress.index > lastProgressIndex.current + 5) {
                                    // Only update every 5 points for performance
                                    updateProgressiveRoute(progress)
                                    lastProgressIndex.current = progress.index
                                }
                            }
                        }

                        // Enviar coordenadas para o servidor (Persist√™ncia & Clientes)
                        // IMPORTANTE: Envia activeClientId para que o Gateway fa√ßa o roteamento correto via socket.to()
                        const payload = {
                            driverId: user.id || user.driver_id, // Fallback safety
                            lat: latitude,
                            lng: longitude,
                            activeClientId: activeRide ? activeRide.clientId : null
                        }
                        socketRef.current.emit('update_location', payload)
                    },
                    (error) => {
                        console.error('Erro de GPS:', error)
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 5000
                    }
                )
            } else {
                toast.error('GPS n√£o suportado neste navegador.')
            }
        }

        return () => {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId)
                console.log('üõë GPS Parado.')
            }
        }
    }, [isOnline, activeRide, user])

    // STATE RESILIENCE: Save to localStorage on change
    useEffect(() => {
        if (activeRide) {
            localStorage.setItem('tot_active_ride', JSON.stringify({
                ride: activeRide,
                status: rideStatus
            }))
        } else {
            localStorage.removeItem('tot_active_ride')
        }
    }, [activeRide, rideStatus])

    // GERENCIAMENTO DE MAPA EM TEMPO REAL
    const mapInstance = useRef(null)
    const driverMarker = useRef(null)

    // CALCULAR ROTA AUTOM√ÅTICA
    useEffect(() => {
        const calculateAndDrawRoute = async () => {
            if (!activeRide || !mapInstance.current || !window.H) return

            let start = null
            let end = null

            // Rota 1: Motorista -> Cliente (Accepted)
            if (rideStatus === 'accepted') {
                if (!latestCoords.current) return
                start = latestCoords.current

                // BACKEND: formatTrip envia 'coords' {lat, lng} para origem
                if (activeRide.coords && activeRide.coords.lat && activeRide.coords.lng) {
                    end = { lat: activeRide.coords.lat, lng: activeRide.coords.lng }
                } else {
                    console.warn('‚ö†Ô∏è Sem coordenadas de pickup (activeRide.coords) para rota.', activeRide)
                    // Fallback para pickupLat se existir
                    if (activeRide.pickupLat && activeRide.pickupLng) {
                        end = { lat: activeRide.pickupLat, lng: activeRide.pickupLng }
                    } else {
                        return
                    }
                }
            }
            // Rota 2: Cliente -> Destino (Ongoing)
            else if (rideStatus === 'ongoing') {
                if (!latestCoords.current) return

                // FIXED: Start is Driver Location (was static pickup)
                start = latestCoords.current

                // BACKEND: formatTrip envia 'coords' (origem) e 'destPos' (destino)
                if (activeRide.destPos && activeRide.destPos.lat) {
                    end = { lat: activeRide.destPos.lat, lng: activeRide.destPos.lng }
                } else if (activeRide.destLat && activeRide.destLng) {
                    end = { lat: activeRide.destLat, lng: activeRide.destLng }
                }
            }

            if (start && end) {
                // Pre-Validation to avoid API spam
                if (
                    typeof start.lat !== 'number' || typeof start.lng !== 'number' ||
                    typeof end.lat !== 'number' || typeof end.lng !== 'number'
                ) {
                    console.warn('‚ö†Ô∏è Coordenadas inv√°lidas para rota:', start, end)
                    return
                }

                console.log('üõ£Ô∏è Calculando rota:', start, end)
                const routeData = await hereRoutingService.getRoute(start, end)
                if (routeData && mapInstance.current && typeof mapInstance.current.addObject === 'function') {
                    // Atualizar estado de navega√ß√£o
                    if (routeData.actions) {
                        setNavigationInstructions(routeData.actions)
                        // Pega a primeira manobra relevante (que n√£o seja 'depart')
                        const nextAction = routeData.actions.find(a => a.action !== 'depart') || routeData.actions[0]
                        setCurrentManeuver(nextAction)
                    }

                    // UPDATE STATS
                    if (routeData.distanceKm && routeData.durationMin) {
                        setRideStats({
                            distance: routeData.distanceKm + ' km',
                            time: routeData.durationMin + ' min'
                        })
                    }

                    // Remover rotas anteriores? Idealmente sim.
                    mapInstance.current.getObjects().forEach(obj => {
                        if (obj instanceof window.H.map.Polyline) {
                            mapInstance.current.removeObject(obj)
                        }
                    })


                    // Salvar geometria para verifica√ß√£o de desvio
                    currentRouteRef.current = routeData.geometry

                    const lineString = new window.H.geo.LineString()
                    routeData.geometry.forEach(p => lineString.pushPoint({ lat: p[0], lng: p[1] }))
                    const polyline = new window.H.map.Polyline(lineString, {
                        style: { lineWidth: 5, strokeColor: '#00afea' }
                    })
                    mapInstance.current.addObject(polyline)

                    // Zoom na rota
                    mapInstance.current.getViewModel().setLookAtData({
                        bounds: polyline.getBoundingBox(),
                        padding: { top: 100, bottom: 100, left: 50, right: 50 }
                    })

                    // ADICIONAR MARCADORES DE ORIGEM E DESTINO
                    // Remove markers anteriores de rota
                    mapInstance.current.getObjects().forEach(obj => {
                        if (obj.getData && obj.getData() === 'route-marker') {
                            mapInstance.current.removeObject(obj)
                        }
                    })

                    // Marcador B (End) - Cliente ou Destino Final
                    const endIcon = new window.H.map.DomIcon(`
                        <div style="background: ${rideStatus === 'accepted' ? '#00afea' : '#E91E63'}; width: 24px; height: 24px; border-radius: 50%; border: 3px solid white; box-shadow: 0 4px 6px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;">
                            <div style="width: 8px; height: 8px; background: white; border-radius: 50%;"></div>
                        </div>
                    `)
                    const endMarker = new window.H.map.DomMarker(end, { icon: endIcon })
                    endMarker.setData('route-marker') // Tag para remover depois
                    mapInstance.current.addObject(endMarker)
                }
            }
        }

        calculateAndDrawRoute()
    }, [activeRide, rideStatus, forceRouteUpdate]) // Added forceRouteUpdate trigger

    const checkRouteDeviation = async (lat, lng) => {
        if (!currentRouteRef.current || isRecalculating.current) return

        // Verificar dist√¢ncia do ponto atual para a linha da rota
        const routeLine = new window.H.geo.LineString(currentRouteRef.current)
        const myPoint = new window.H.geo.Point(lat, lng)

        // HERE API n√£o tem distanceToPoint nativo na geometria simples, mas podemos simplificar:
        // Se a dist√¢ncia para o bounding box for grande, ou calculando dist√¢ncia para pontos pr√≥ximos
        // Para simplificar, vamos verificar se estamos longe de todos os pontos da rota por > 50m
        // (Uma implementa√ß√£o real usaria H.geo.LineString.extractPoint para proje√ß√£o)

        // Simplifica√ß√£o: Verifica a cada 10 pontos para performance
        let minDistance = Infinity
        for (let i = 0; i < currentRouteRef.current.length; i += 5) {
            const p = currentRouteRef.current[i]
            const dist = haversine(lat, lng, p[0], p[1]) // Implementar haversine helper
            if (dist < minDistance) minDistance = dist
        }

        if (minDistance > 0.05) { // 50 metros
            console.log('‚ö†Ô∏è Desvio de rota detectado! Recalculando...')
            isRecalculating.current = true
            toast('Recalculando rota...', { icon: 'üîÑ' })

            // For√ßar recalculo (chamar calculateAndDrawRoute ou similar)
            // Como calculateAndDrawRoute depende de activeRide/rideStatus, podemos disparar um re-render ou chamar direto se extrairmos
            // Vamos apenas limpar a rota atual para o useEffect disparar novamente? N√£o, useEffect depende de activeRide.
            // Vamos chamar a fun√ß√£o de rota manualmente.
            await calculateRouteManual()
            isRecalculating.current = false
        }
    }

    const updateNavigationState = (lat, lng) => {
        if (!navigationInstructions.length) return

        // Encontrar a manobra mais pr√≥xima
        const nextManeuver = navigationInstructions.find(action => {
            // L√≥gica simples: Se a dist√¢ncia para a manobra for < 20m, mostrar a pr√≥xima
            // Isso requer coordenadas da manobra. A API v8 retorna 'offset', precisamos mapear para lat/lng da geometria
            // Para MVP Turn-by-Turn, vamos apenas exibir a primeira manobra da lista e remov√™-la quando passarmos?
            // Melhor: Calcular dist√¢ncia at√© a manobra atual
            return true
        })

        // Atualizar dist√¢ncia restante da manobra atual
        if (currentManeuver) {
            // ... l√≥gica de atualiza√ß√£o de dist√¢ncia em tempo real
        }
    }

    // Helper Haversine (Dist√¢ncia em km)
    const haversine = (lat1, lon1, lat2, lon2) => {
        const R = 6371; // km
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }

    // PREMIUM FEATURE: Calculate route progress
    const calculateRouteProgress = (routeGeometry, currentPosition) => {
        if (!routeGeometry || routeGeometry.length === 0) return null

        let minDistance = Infinity
        let closestIndex = 0

        // Find closest point on route
        routeGeometry.forEach((point, index) => {
            const dist = haversine(
                currentPosition.lat, currentPosition.lng,
                point[0], point[1]
            )
            if (dist < minDistance) {
                minDistance = dist
                closestIndex = index
            }
        })

        return {
            index: closestIndex,
            percentComplete: (closestIndex / routeGeometry.length) * 100,
            distanceFromRoute: minDistance
        }
    }

    // PREMIUM FEATURE: Create sparkle animation at specific map coordinates
    const createSparkle = (lat, lng) => {
        if (!mapInstance.current || !window.H) return

        // Convert map lat/lng to screen pixels
        const screenPos = mapInstance.current.geoToScreen({ lat, lng })
        if (!screenPos) return

        const sparkle = document.createElement('div')
        sparkle.className = 'route-sparkle'

        // Random offsets to make it look organic
        const tx = (Math.random() - 0.5) * 80
        const ty = (Math.random() - 0.5) * 80

        sparkle.style.left = `${screenPos.x}px`
        sparkle.style.top = `${screenPos.y}px`
        sparkle.style.setProperty('--tx', `${tx}px`)
        sparkle.style.setProperty('--ty', `${ty}px`)

        document.body.appendChild(sparkle)

        // Remove after animation completes
        setTimeout(() => {
            if (sparkle.parentNode) sparkle.parentNode.removeChild(sparkle)
        }, 1000)
    }

    // PREMIUM FEATURE: Update progressive route visualization
    const updateProgressiveRoute = (progress) => {
        if (!mapInstance.current || !currentRouteRef.current || !window.H) return

        const geometry = currentRouteRef.current
        const splitIndex = progress.index

        // Remove old polylines
        if (completedPolylineRef.current) {
            mapInstance.current.removeObject(completedPolylineRef.current)
            completedPolylineRef.current = null
        }
        if (remainingPolylineRef.current) {
            mapInstance.current.removeObject(remainingPolylineRef.current)
            remainingPolylineRef.current = null
        }
        if (transitionPolylineRef.current) {
            mapInstance.current.removeObject(transitionPolylineRef.current)
            transitionPolylineRef.current = null
        }

        // TRIGGER SPARKLES at current position
        const currentCoord = geometry[splitIndex]
        if (currentCoord) {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => createSparkle(currentCoord[0], currentCoord[1]), i * 150)
            }
        }

        // Completed segment (gray, faded)
        if (splitIndex > 2) {
            const completedGeometry = geometry.slice(0, splitIndex - 2)
            const completedLine = new window.H.geo.LineString()
            completedGeometry.forEach(p => completedLine.pushPoint({ lat: p[0], lng: p[1] }))

            const completedPolyline = new window.H.map.Polyline(completedLine, {
                style: {
                    strokeColor: '#94a3b8',
                    lineWidth: 4,
                    opacity: 0.3
                }
            })
            mapInstance.current.addObject(completedPolyline)
            completedPolylineRef.current = completedPolyline
        }

        // Transition segment (semi-transparent pink glow)
        const transStart = Math.max(0, splitIndex - 2)
        const transEnd = Math.min(geometry.length, splitIndex + 3)
        const transGeometry = geometry.slice(transStart, transEnd)
        if (transGeometry.length > 1) {
            const transLine = new window.H.geo.LineString()
            transGeometry.forEach(p => transLine.pushPoint({ lat: p[0], lng: p[1] }))

            const transPolyline = new window.H.map.Polyline(transLine, {
                style: {
                    strokeColor: '#E91E63',
                    lineWidth: 6,
                    opacity: 0.6
                }
            })
            mapInstance.current.addObject(transPolyline)
            transitionPolylineRef.current = transPolyline
        }

        // Remaining segment (pink, bright)
        if (splitIndex + 2 < geometry.length) {
            const remainingGeometry = geometry.slice(splitIndex + 2)
            const remainingLine = new window.H.geo.LineString()
            remainingGeometry.forEach(p => remainingLine.pushPoint({ lat: p[0], lng: p[1] }))

            const remainingPolyline = new window.H.map.Polyline(remainingLine, {
                style: {
                    strokeColor: '#E91E63',
                    lineWidth: 5,
                    opacity: 1.0
                }
            })
            mapInstance.current.addObject(remainingPolyline)
            remainingPolylineRef.current = remainingPolyline
        }
    }

    const calculateRouteManual = async () => {
        // Re-run route calc logic
        // (Idealmente extrair calculateAndDrawRoute do useEffect)
        // Por agora, vamos setar activeRide com um timestamp update fake para triggar o useEffect?
        // Ou melhor, setar um estado 'forceUpdate'
        setForceRouteUpdate(prev => prev + 1)
    }

    // Helper: Calcular Bearing (Rota√ß√£o do ve√≠culo)
    const calculateBearing = (startLat, startLng, destLat, destLng) => {
        const toRad = (deg) => deg * Math.PI / 180;
        const toDeg = (rad) => rad * 180 / Math.PI;

        const startLatRad = toRad(startLat);
        const startLngRad = toRad(startLng);
        const destLatRad = toRad(destLat);
        const destLngRad = toRad(destLng);

        const y = Math.sin(destLngRad - startLngRad) * Math.cos(destLatRad);
        const x = Math.cos(startLatRad) * Math.sin(destLatRad) -
            Math.sin(startLatRad) * Math.cos(destLatRad) * Math.cos(destLngRad - startLngRad);

        let brng = Math.atan2(y, x);
        return (toDeg(brng) + 360) % 360;
    }

    const lastMarkerPos = useRef(null)
    const animationFrameRef = useRef(null)

    const updateDriverMarker = (lat, lng) => {
        if (!mapInstance.current || !window.H) return

        const newLatLng = { lat, lng }

        if (driverMarker.current) {
            // ANIMAR TRANSI√á√ÉO
            const startPos = lastMarkerPos.current || driverMarker.current.getGeometry()
            const startTime = performance.now()
            const duration = 1000 // 1 segundo de anima√ß√£o (suaviza updates de 1s do GPS)

            // Calcular rota√ß√£o (bearing)
            const bearing = calculateBearing(startPos.lat, startPos.lng, lat, lng)

            // PREMIUM FEATURE: Heading-Up Rotation (map follows direction)
            if (isRideActive && bearing !== null && !isNaN(bearing)) {
                mapInstance.current.setHeading(bearing, true) // true = animate
            }

            // Atualizar rota√ß√£o do √≠cone CSS
            const iconElement = driverMarker.current.getIcon().getElement()
            if (iconElement) {
                const carIcon = iconElement.querySelector('.driver-marker-pulse') || iconElement.querySelector('.marker-icon-wrapper')
                if (carIcon) {
                    carIcon.style.transform = `rotate(${bearing}deg)`
                    carIcon.style.transition = 'transform 0.5s ease'
                }
            }

            const animate = (time) => {
                const elapsed = time - startTime
                const progress = Math.min(elapsed / duration, 1) // 0 a 1

                // Lerp (Linear Interpolation)
                const currentLat = startPos.lat + (lat - startPos.lat) * progress
                const currentLng = startPos.lng + (lng - startPos.lng) * progress

                driverMarker.current.setGeometry({ lat: currentLat, lng: currentLng })

                // Centralizar mapa se estiver seguindo (opcional, pode ser intrusivo)
                // mapInstance.current.setCenter({ lat: currentLat, lng: currentLng })

                if (progress < 1) {
                    animationFrameRef.current = requestAnimationFrame(animate)
                } else {
                    lastMarkerPos.current = newLatLng

                    // PREMIUM FEATURE: Auto-centering (keep driver in center)
                    if (isRideActive && mapInstance.current) {
                        mapInstance.current.setCenter(newLatLng, true) // true = animate
                    }
                }
            }

            if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current)
            animationFrameRef.current = requestAnimationFrame(animate)

        } else {
            // Inicializar Marcador PREMIUM
            const icon = new window.H.map.DomIcon(`
                <div class="driver-marker-premium">
                    <svg width="44" height="44" viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <radialGradient id="driverIconGradient" cx="50%" cy="50%" r="50%">
                                <stop offset="0%" style="stop-color:#C2185B;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#E91E63;stop-opacity:1" />
                            </radialGradient>
                            <filter id="driverIconShadow" x="-50%" y="-50%" width="200%" height="200%">
                                <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
                                <feOffset dx="0" dy="2" result="offsetblur"/>
                                <feComponentTransfer>
                                    <feFuncA type="linear" slope="0.3"/>
                                </feComponentTransfer>
                                <feMerge>
                                    <feMergeNode/>
                                    <feMergeNode in="SourceGraphic"/>
                                </feMerge>
                            </filter>
                        </defs>
                        <!-- Main circle with gradient -->
                        <circle cx="22" cy="22" r="18" 
                                fill="url(#driverIconGradient)" 
                                stroke="white" 
                                stroke-width="3"
                                filter="url(#driverIconShadow)"/>
                        <!-- White chevron indicator -->
                        <path d="M 22 14 L 18 22 L 22 20 L 26 22 Z" 
                              fill="white" 
                              opacity="0.95"/>
                    </svg>
                </div>
            `, {
                onAttach: (element) => {
                    // Centralizar √¢ncora
                    element.style.marginTop = '-22px'
                    element.style.marginLeft = '-22px'
                }
            })
            const marker = new window.H.map.DomMarker(newLatLng, { icon })
            mapInstance.current.addObject(marker)
            driverMarker.current = marker
            lastMarkerPos.current = newLatLng
        }
    }

    // GERENCIAMENTO DE SOCKET (ESTABILIZADO)
    useEffect(() => {
        if (user) {
            fetchStats() // Fetch on mount
            socketRef.current = io(SOCKET_URL)

            socketRef.current.on('connect', () => {
                console.log('Socket Connected, joining room...')
                socketRef.current.emit('join', { userId: user.id, role: 'driver' })
            })

            socketRef.current.on('login_status', (status) => {
                console.log('Login status from server:', status)
                setIsOnline(status.isOnline)
                if (status.isOnline) fetchPendingTrips(true)
            })

            socketRef.current.on('new_trip_available', (trip) => {
                console.log('üîî [NEW_TRIP] Recebido:', trip);
                console.log('üìã [NEW_TRIP] Estado atual de requests:', requests.length);

                // S√ì mostra novas corridas se o estado local for IDLE e estiver online
                // (O backend j√° filtra por online, mas mantemos seguran√ßa no front)
                setRequests(prev => {
                    console.log('üìã [NEW_TRIP] Requests antes:', prev.length);
                    if (prev.find(r => r.id === trip.id)) {
                        console.log('‚ö†Ô∏è [NEW_TRIP] Viagem j√° existe na lista, ignorando');
                        return prev;
                    }
                    const newList = [trip, ...prev];
                    console.log('‚úÖ [NEW_TRIP] Viagem adicionada. Total:', newList.length);
                    return newList;
                });
                toast.success('NOVA CORRIDA!', { icon: 'üèéÔ∏è', style: { background: '#E91E63', color: '#fff' } });
            })

            socketRef.current.on('pending_trips', (trips) => {
                console.log('Received pending trips:', trips)
                // NO auto-online here. Trust the login_status and toggle_online events.
                setRequests(trips)
            })

            socketRef.current.on('trip_taken', (data) => {
                console.log('üö® [TRIP_TAKEN] Recebido:', data);

                // CRITICAL: N√£o remover se foi este motorista quem aceitou
                if (data.acceptedBy && data.acceptedBy === user.id) {
                    console.log('‚úÖ [TRIP_TAKEN] Ignorando - foi este motorista quem aceitou');
                    return;
                }

                console.log('üìã [TRIP_TAKEN] Removendo viagem da lista');
                setRequests(prev => {
                    const filtered = prev.filter(req => req.id !== data.tripId);
                    console.log(`üìã [TRIP_TAKEN] Requests: ${prev.length} -> ${filtered.length}`);
                    return filtered;
                });
            })

            socketRef.current.on('restore_ride', (trip) => {
                console.log('Restoring ride from DB:', trip)
                setActiveRide(trip)
                setRideStatus(trip.status === 'accepted' ? 'accepted' : 'ongoing')
                if (trip.status === 'ongoing') {
                    setFare(parseFloat(trip.current_fare) || 0)
                }
            })

            socketRef.current.on('trip_cancelled', (data) => {
                toast.error('Corrida cancelada pelo cliente.', { duration: 5000 })
                setActiveRide(null)
                setRideStatus('idle')
                setFare(0)
            })

            socketRef.current.on('trip_cancelled_global', (data) => {
                setRequests(prev => prev.filter(req => req.id !== data.tripId))
            })

            // CRITICAL: Listen for account suspension in real-time
            socketRef.current.on('account_suspended', (data) => {
                console.log('‚õî Account suspended:', data)
                toast.error(data.message || 'Sua conta foi suspensa pelo administrador', { duration: 5000 })
                // Force logout and update user status
                const updatedUser = { ...user, status: 'suspended' }
                localStorage.setItem('tot_driver_user', JSON.stringify(updatedUser))
                // Reload to trigger App.jsx routing to /suspended
                setTimeout(() => window.location.reload(), 2000)
            })

            // Listen for account activation
            socketRef.current.on('account_activated', (data) => {
                console.log('‚úÖ Account activated:', data)
                toast.success(data.message || 'Sua conta foi reativada!', { duration: 5000 })
                const updatedUser = { ...user, status: 'active' }
                localStorage.setItem('tot_driver_user', JSON.stringify(updatedUser))
            })

            const heartbeatInterval = setInterval(() => {
                if (socketRef.current?.connected) {
                    socketRef.current.emit('ping')
                }
            }, 30000)

            return () => {
                if (socketRef.current) socketRef.current.disconnect()
                clearInterval(heartbeatInterval)
            }
        }
    }, [user]) // rideStatus REMOVED to keep socket connected

    const handleToggleStatus = () => {
        if (activeRide) {
            toast.error('Finalize a corrida atual primeiro!')
            return
        }

        const newStatus = !isOnline
        setIsOnline(newStatus)

        if (newStatus) {
            toast.success('Voc√™ est√° ONLINE!', { style: { background: '#E91E63', color: '#fff' } })
            fetchPendingTrips(true)
        } else {
            setRequests([])
            toast('Voc√™ est√° OFFLINE', { icon: 'üí§' })
        }

        if (socketRef.current) {
            socketRef.current.emit('toggle_online', { userId: user.id, isOnline: newStatus })
        }

    }

    const handleAcceptRide = (req) => {
        if (socketRef.current) {
            socketRef.current.emit('accept_trip', {
                tripId: req.id,
                driverId: user.id,
                clientId: req.clientId,
                driverName: user.full_name
            }, (response) => {
                if (response?.success) {
                    setActiveRide(req)
                    setRideStatus('accepted')
                    setRequests([])
                    setFare(parseFloat(req.price) || 1500)
                    toast.success('Corrida aceita! Dirija-se ao cliente.')
                } else {
                    toast.error(response?.error || 'Erro ao aceitar corrida')
                }
            })
        }
    }

    const handleStartRide = () => {
        if (socketRef.current && activeRide) {
            socketRef.current.emit('start_ride', { tripId: activeRide.id, clientId: activeRide.clientId })
            setRideStatus('ongoing')
            toast.success('Corrida Iniciada!')

            // Force local update to avoid waiting for socket echo
            setActiveRide(prev => ({ ...prev, started_at: new Date().toISOString() }))
            startTaximeter()
        }
    }

    const startTaximeter = () => {
        if (fareInterval.current) clearInterval(fareInterval.current)

        // Robust Taximeter Logic
        fareInterval.current = setInterval(() => {
            if (!activeRide || !activeRide.started_at) return

            const now = new Date()
            const startedAt = new Date(activeRide.started_at)
            const elapsedMinutes = (now - startedAt) / 60000

            // Get Pricing from Active Ride (sent by backend formatTrip) or defaults
            const pricePerMin = Number(activeRide.price_per_min) || 50
            const baseFare = Number(activeRide.base_fare) || 500

            // Formula: Base + (Time * Rate)
            // Note: We can add distance logic here later if we trust 'latestCoords' accumulation
            let currentFare = baseFare + (elapsedMinutes * pricePerMin)

            // Round to nearest 10 for clean display
            currentFare = Math.ceil(currentFare / 10) * 10

            setFare(currentFare)

            // Sync with backend less frequently (e.g., every 10s) to save bandwidth
            if (now.getSeconds() % 10 === 0 && socketRef.current) {
                socketRef.current.emit('trip_progress', {
                    tripId: activeRide.id,
                    clientId: activeRide.clientId,
                    currentFare: currentFare,
                    coords: latestCoords.current
                })
            }

        }, 1000) // Update UI every second
    }

    // Effect to auto-start taximeter on refresh if ongoing
    useEffect(() => {
        if (rideStatus === 'ongoing' && activeRide?.started_at) {
            startTaximeter()
        }
        return () => {
            if (fareInterval.current) clearInterval(fareInterval.current)
        }
    }, [rideStatus, activeRide?.started_at])

    const handleCancelRide = () => {
        if (socketRef.current && activeRide) {
            socketRef.current.emit('cancel_trip', {
                tripId: activeRide.id,
                userId: user.id,
                role: 'driver'
            })
            setActiveRide(null)
            setRideStatus('idle')
            setFare(0)
            if (fareInterval.current) clearInterval(fareInterval.current)
            toast('Corrida cancelada.', { icon: 'üö´' })
        }
    }

    const handleFinishRide = () => {
        if (fareInterval.current) clearInterval(fareInterval.current)
        if (socketRef.current && activeRide) {
            socketRef.current.emit('finish_ride', {
                tripId: activeRide.id,
                clientId: activeRide.clientId,
                finalFare: fare.toString()
            })
            setRideStatus('finished')
            toast.success('Viagem Conclu√≠da! Aguardando Pagamento.')
        }
    }

    const handleConfirmPayment = () => {
        if (socketRef.current && activeRide) {
            const receipt = {
                id: activeRide.id,
                driver: user.full_name,
                total: fare,
                date: new Date().toLocaleString(),
                from: activeRide.pickupAddress,
                to: activeRide.destAddress
            }
            socketRef.current.emit('confirm_payment', {
                tripId: activeRide.id,
                clientId: activeRide.clientId,
                receiptData: receipt
            })
            setRideStatus('paid')
            toast.success('Pagamento Confirmado! Recibo Gerado.')
            fetchStats() // Update stats after payment
        }
    }

    const resetToIdle = () => {
        setActiveRide(null)
        setRideStatus('idle')
        setFare(0)
    }

    // Determine if we are in an "active" flow to toggle UI layers
    const isRideActive = activeRide && ['accepted', 'ongoing', 'finished', 'paid'].includes(rideStatus)

    return (
        <div className="driver-dashboard-mobile">

            {/* 1. LAYER 1: DASHBOARD NORMAL (IDLE) - Hidden on Active */}
            {!isRideActive && (
                <>
                    <header className="dash-header-premium" style={{ position: 'relative', zIndex: 10 }}>
                        <div className="header-top">
                            <button className="icon-btn shadow-sm"><Menu size={24} /></button>
                            <h1 className="logo-text-small">TOT</h1>
                            <div className="profile-mini shadow-sm"><User size={20} /></div>
                        </div>
                        <div className="status-selector-container">
                            <div className={`status-pill-big ${isOnline ? 'online' : 'offline'}`}>
                                <span className="status-text">{isOnline ? 'VOC√ä EST√Å ONLINE' : 'VOC√ä EST√Å OFFLINE'}</span>
                                <button className={`toggle-switch ${isOnline ? 'active' : ''}`} onClick={handleToggleStatus}>
                                    <Power size={22} color={isOnline ? '#fff' : '#94a3b8'} />
                                </button>
                            </div>
                        </div>
                    </header>

                    <main className="dash-body" style={{ position: 'relative', zIndex: 10 }}>
                        <section className="welcome-banner">
                            <h2>Ol√°, {user?.full_name?.split(' ')[0] || 'Motorista'}! üëã</h2>
                            <p>Veja seus resultados de hoje</p>
                        </section>

                        <section className="stats-grid-premium">
                            <div className="stat-card-gradient pink-grad shadow-lg">
                                <div className="stat-icon-bg"><Navigation size={22} color="#fff" /></div>
                                <div className="stat-content">
                                    <span className="stat-label">Corridas Hoje</span>
                                    <span className="stat-value">{stats.rides}</span>
                                </div>
                            </div>
                            <div className="stat-card-gradient purple-grad shadow-lg">
                                <div className="stat-icon-bg"><DollarSign size={22} color="#fff" /></div>
                                <div className="stat-content">
                                    <span className="stat-label">Total Faturado</span>
                                    <span className="stat-value">Kz {Number(stats.earnings).toLocaleString()}</span>
                                </div>
                            </div>
                        </section>

                        <section className="requests-section">
                            <div className="section-header">
                                <h3>Solicita√ß√µes Pr√≥ximas</h3>
                                <span className="badge-pulse">{requests.length}</span>
                            </div>

                            <div className="requests-list">
                                {isOnline ? (
                                    requests && requests.length > 0 ? (
                                        requests.filter(r => r && r.id).map(req => (
                                            <div key={req.id} className="request-card shadow-sm animate-fade-in">
                                                <div className="req-header">
                                                    <div className="user-info-mini">
                                                        <div className="avatar-letter">{req.userName ? req.userName[0] : 'U'}</div>
                                                        <div className="user-text">
                                                            <strong>{req.userName}</strong>
                                                            <span>‚≠ê 4.8</span>
                                                        </div>
                                                    </div>
                                                    <div className="price-tag-req">
                                                        Kz {Number(req.price).toLocaleString()}
                                                    </div>
                                                </div>

                                                <div className="req-route-info">
                                                    <div className="route-point">
                                                        <div className="dot start"></div>
                                                        <p>{req.pickupAddress}</p>
                                                    </div>
                                                    <div className="route-line-vertical"></div>
                                                    <div className="route-point">
                                                        <div className="dot end"></div>
                                                        <p>{req.destAddress}</p>
                                                    </div>
                                                </div>

                                                <div className="req-actions">
                                                    <button className="btn-accept" onClick={() => handleAcceptRide(req)}>
                                                        ACEITAR CORRIDA
                                                    </button>
                                                </div>
                                            </div>
                                        ))
                                    ) : (
                                        <div className="empty-state-requests">
                                            <div className="radar-animation"></div>
                                            <p>Procurando passageiros...</p>
                                        </div>
                                    )
                                ) : (
                                    <div className="offline-state-box">
                                        <Power size={40} color="#cbd5e1" />
                                        <p>Voc√™ est√° offline</p>
                                        <button className="btn-go-online" onClick={handleToggleStatus}>FICAR ONLINE</button>
                                    </div>
                                )}
                            </div>
                        </section>
                    </main>
                </>
            )}

            {/* 2. LAYER 2: ACTIVE RIDE OVERLAY (NEW REDESIGN) */}
            {isRideActive && (
                <div className="ride-active-structure">

                    {/* A. MAP BACKGROUND */}
                    <div className="ride-active-map-layer">
                        <HereMap
                            center={latestCoords.current}
                            zoom={17}
                            onMapReady={(map) => {
                                mapInstance.current = map
                            }}
                        />
                    </div>

                    {/* B. TOP NAVIGATION CARD (PINK) */}
                    <div className="active-ride-nav-card">
                        <div className="nav-card-icon-box">
                            {currentManeuver ? getManeuverIcon(currentManeuver.action) : <ArrowUp size={30} color="white" />}
                        </div>
                        <div className="nav-card-content">
                            <div className="nav-distance-main">
                                {currentManeuver ? `${currentManeuver.length}m` : '0m'}
                            </div>
                            <div className="nav-instruction-main">
                                {currentManeuver ? translateInstruction(currentManeuver.instruction) : 'Siga a rota'}
                            </div>
                        </div>
                        <div className="nav-card-stats">
                            <div className="nav-stat-row">
                                <Clock size={14} color="rgba(255,255,255,0.8)" />
                                <span>{rideStats.time}</span>
                            </div>
                            <div className="nav-stat-row">
                                <Navigation size={14} color="rgba(255,255,255,0.8)" />
                                <span>{rideStats.distance}</span>
                            </div>
                            <div className="nav-price-tag">
                                {Number(fare).toLocaleString()} Kz
                            </div>
                        </div>
                    </div>

                    {/* C. BOTTOM SHEET (WHITE) */}
                    <div className={`active-ride-bottom-sheet ${isModalMinimized ? 'minimized' : ''}`}>
                        {/* Toggle Minimized Header */}
                        <div className="sheet-header-row">
                            <div className="client-info-group">
                                <div className="client-pic">{activeRide.userName?.[0] || 'U'}</div>
                                <div className="client-texts">
                                    <h4>{activeRide.userName}</h4>
                                    <span>Cliente TOT Premium</span>
                                </div>
                            </div>
                            <button className="btn-minimize-sheet" onClick={() => setIsModalMinimized(true)}>
                                <Minimize2 size={20} />
                            </button>
                        </div>

                        {/* Delivery Info if applicable */}
                        {activeRide.category === 'delivery' && activeRide.deliveryInfo && (
                            <div className="delivery-detail-box animate-fade-in" style={{ marginBottom: '10px' }}>
                                <div className="delivery-item">
                                    <div className="icon-wrap"><User size={16} /></div>
                                    <div className="delivery-item-text">
                                        <span className="label">Destinat√°rio</span>
                                        <span className="val">{activeRide.deliveryInfo.recipientName}</span>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Dynamic Address Display based on Status */}
                        <div className="destination-info" style={{ marginBottom: '15px' }}>
                            <span className="dest-label">
                                {rideStatus === 'accepted' ? 'ENDERE√áO DO CLIENTE' : 'DESTINO DA VIAGEM'}
                            </span>
                            <div className="info-row">
                                <MapPin size={18} color="#E91E63" />
                                <span className="text-truncate">
                                    {rideStatus === 'accepted'
                                        ? (activeRide.pickupAddress || activeRide.originAddress || 'Endere√ßo n√£o dispon√≠vel')
                                        : (activeRide.destAddress || 'Destino n√£o dispon√≠vel')
                                    }
                                </span>
                            </div>
                        </div>

                        {/* Actions Grid */}
                        <div className="sheet-actions-grid">
                            <button className="action-btn-secondary">
                                <Phone size={18} /> Ligar
                            </button>
                            <button className="action-btn-secondary">
                                <MessageSquare size={18} /> Chat
                            </button>
                        </div>

                        {/* Main Action Slider Button */}
                        <div className="main-action-slider">
                            {rideStatus === 'accepted' && (
                                <div className="flex flex-col gap-2">
                                    <button className="btn-main-action start" onClick={handleStartRide}>
                                        <Play size={20} fill="white" /> INICIAR CORRIDA
                                    </button>
                                    <button className="btn-ride-control cancel-mini" onClick={handleCancelRide} style={{ background: '#fef2f2', color: '#ef4444', height: '40px', fontSize: '14px', border: 'none', borderRadius: '15px' }}>
                                        CANCELAR
                                    </button>
                                </div>
                            )}
                            {rideStatus === 'ongoing' && (
                                <button className="btn-main-action finish" onClick={handleFinishRide}>
                                    <Square size={20} fill="white" /> FINALIZAR CORRIDA
                                </button>
                            )}
                            {rideStatus === 'finished' && (
                                <button className="btn-main-action pay" onClick={handleConfirmPayment}>
                                    <CreditCard size={20} /> RECEBER PAGAMENTO
                                </button>
                            )}
                            {rideStatus === 'paid' && (
                                <div className="concluded-actions">
                                    <button className="btn-receipt-view" onClick={() => navigate('/history')}>VER RECIBO</button>
                                    <button className="btn-back-home" onClick={resetToIdle}>VOLTAR AO IN√çCIO</button>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* D. RESTORE BUTTON (Shown when minimized) */}
                    {isModalMinimized && (
                        <button className="ride-restore-btn animate-pop-in" onClick={() => setIsModalMinimized(false)}>
                            <Maximize2 size={24} />
                        </button>
                    )}

                </div>
            )}
        </div>
    )
}
